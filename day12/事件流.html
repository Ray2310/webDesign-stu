<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <p>点击大的复选框的按钮之后， 所有的小复选checked按钮都和其统一checked</p>
  <h1>一、事件流</h1>
  <h2>1.1. 事件流的两个阶段</h2>
  <p> 定义： 事件流是指的事件完整执行过程中的流动路径
    <br>
    两个阶段： 捕获 、 冒泡
  </p>

   <h2>1.2 事件捕获</h2>
    <p>
    捕获： 就是从DOM的根元素开始去执行对应的事件(从外到内的过程)
    <br>
    事件捕获需要对应的代码才能看到效果
    </p>
    <p style="color: red;">代码: `dom.addEventListener(事件类型,事件处理函数,是否使用捕获机制) //true or false`</p>

    <p>如果是L0事件，那么就不会使用事件捕获</p>


  <h2>1.3. 事件冒泡</h2>
    <p>当一个元素的事件被触发的时候，同样的事件将会在该元素的所有祖先元素中依次被触发， 这一过程被称为事件冒泡</p>
    <p style="background-color: antiquewhite;">简单理解： 当一个元素事件被触发后，会依次向上调用所有父级元素的同名事件</p>
    <p>
      事件冒泡是默认存在的
    </p>


  <h2>1.4 阻止冒泡</h2>
  <p> 
    因为冒泡事件是默认存在的 ， 所以容易导致事件影响父级元素
    <br>
    阻止事件的前提是拿到事件对象
  </p>
  <p style="color: red;">
    事件对象.stopPropagation() // 注意， 此方法可以阻止事件流动传播， 不光在冒泡阶段有效， 捕获阶段也有效
    <br>
    元素.addEventListener('click', function(e){ <br>
    })
  </p>


  <h2>1.5 解绑事件</h2>
  <p>
    将绑定的事件接触
    <br>元素.addEventListener('click', function(){ <br>
      元素.onclick = null  //解绑事件 <br>
    })
  </p>

  <h1>二、事件委托</h1>

  <p  style="background-color: aqua;">
    事件冒泡好的方面: 
    假设:需要同时给多个元素注册事件， 一般我们是使用for循环的方式 。还可以使用事件委托。让其代为注册事件
    <br> 委托就可以减少注册事件的次数， 提高了性能
    <br> 原理就是： 利用事件冒泡的特点， 实现触发子元素的同时 会冒泡到父元素身上 ，从而触发父元素的事件
  </p>

  <p>给父元素注册事件， 当我们触发子元素的时候，会冒泡到父元素身上， 从而触发父元素的事件， 所以只需要给父元素注册事件就可以实现所有子元素的事件触发</p>
  <p style="color: blueviolet;">
    实现: 事件对象.target.tagName 可以获得真正触发事件的元素 。比如 li ---> LI
    <br>
    <br>
    实现地方： ul li 列表中， 可以通过给ul注册事件， 通过点击li的内容 实现触发子元素的同时
  </p>

  <ul>
    <li>测试事件委托的作用</li>
    <li>测试1</li>
    <li>测试2</li>
    <li>测试3</li>
  </ul>
  
  <button>点击跳转</button>
  <h2>阻止默认行为</h2>
  <p style="color: red;">案例：
  <br>
    在表单提交中， 如果填的某些内容不正确， 就无法提交表单。 
    <br>
    如何阻止： 
    <br>
    通过事件， 使用e.preventDefault() 来实现阻止默认行为
  </p>
  <form action="https://wclspace.xyz" method="post">
    <input type="submit" name="" id="" value="进入Rayce个人网站">
  </form>


  请输入内容: <input type="text">
  <h1>三、其他事件 在day13中有实现案例</h1>
  <h2>  页面加载事件</h2>
  <p> 通过页面加载事件来实现等待页面加载完成时触发的事件</p>
  <p style="color: red;">事件名: load
  <br>
  window.addEventListener('load',function(){
    <br>  //页面加载事件
    <br> //...需要执行的页面加载内容
    <br>
  }) 
</p>
<p>如果我们需要将页面加载完成后立马执行某个内容， 就可以通过页面加载事件来实现</p>


  <h2>页面加载事件 DOMContentLoaded事件</h2>
    <p style="background-color: bisque;">
    当初始的html文档加载完成后， DOMContentLoaded事件被执行。他比上面的load执行的快。
    <br>
    document.addEventListener('DOMContentLoaded', function(){ })
    </p>

  <h2>页面滚动事件</h2>
  <p>比如： 返回顶部、固定导航栏</p>
  <p style="background-color: aqua;">
    语法： 
    <br>
    <br> window.addEventListener('scroll',function(){
    <br>//页面滚动事件
    <br>//...需要执行的页面滚动内容
    <br>})
  </p>
  <p>
    拉取滚动条他就能立马进行滚动， 也可以给元素内部添加。
  </p>
  <h3>获取滚动的位置: scrollLeft 和 scrollTop 
    <br>1. 获取被卷去的大小
    <br>2. 获取元素内容往左、往上滚出去看不到的距离
    <br>3. div.scrollTop 这个得到的是看不到的像素。 值是可读写的
  </h3>

  <h3></h3>



  <h1>四、元素尺寸与位置</h1>


  <script src="./shijianliu.js"></script>
</body>
</html>