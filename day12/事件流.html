<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <p>点击大的复选框的按钮之后， 所有的小复选checked按钮都和其统一checked</p>
  <h1>一、事件流</h1>
  <h2>1.1. 事件流的两个阶段</h2>
  <p> 定义： 事件流是指的事件完整执行过程中的流动路径
    <br>
    两个阶段： 捕获 、 冒泡
  </p>

   <h2>1.2 事件捕获</h2>
    <p>
    捕获： 就是从DOM的根元素开始去执行对应的事件(从外到内的过程)
    <br>
    事件捕获需要对应的代码才能看到效果
    </p>
    <p style="color: red;">代码: `dom.addEventListener(事件类型,事件处理函数,是否使用捕获机制) //true or false`</p>

    <p>如果是L0事件，那么就不会使用事件捕获</p>


  <h2>1.3. 事件冒泡</h2>
    <p>当一个元素的事件被触发的时候，同样的事件将会在该元素的所有祖先元素中依次被触发， 这一过程被称为事件冒泡</p>
    <p style="background-color: antiquewhite;">简单理解： 当一个元素事件被触发后，会依次向上调用所有父级元素的同名事件</p>
    <p>
      事件冒泡是默认存在的
    </p>


  <h2>1.4 阻止冒泡</h2>
  <p> 
    因为冒泡事件是默认存在的 ， 所以容易导致事件影响父级元素
    <br>
    阻止事件的前提是拿到事件对象
  </p>
  <p style="color: red;">
    事件对象.stopPropagation() // 注意， 此方法可以阻止事件流动传播， 不光在冒泡阶段有效， 捕获阶段也有效
    <br>
    元素.addEventListener('click', function(e){ <br>
    })
  </p>


  <h2>1.5 解绑事件</h2>
  <p>
    将绑定的事件接触
    <br>元素.addEventListener('click', function(){ <br>
      元素.onclick = null  //解绑事件 <br>
    })
  </p>

  <h1>二、事件委托</h1>

  <p  style="background-color: aqua;">
    事件冒泡好的方面: 
    假设:需要同时给多个元素注册事件， 一般我们是使用for循环的方式 。还可以使用事件委托。让其代为注册事件
    <br> 委托就可以减少注册事件的次数， 提高了性能
    <br> 原理就是： 利用事件冒泡的特点， 实现触发子元素的同时 会冒泡到父元素身上 ，从而触发父元素的事件
  </p>

  <p>给父元素注册事件， 当我们触发子元素的时候，会冒泡到父元素身上， 从而触发父元素的事件， 所以只需要给父元素注册事件就可以实现所有子元素的事件触发</p>
  <p style="color: blueviolet;">
    实现: 事件对象.target.tagName 可以获得真正触发事件的元素 。比如 li ---> LI
    <br>
    <br>
    实现地方： ul li 列表中， 可以通过给ul注册事件， 通过点击li的内容 实现触发子元素的同时
  </p>

  <ul>
    <li>测试事件委托的作用</li>
    <li>测试1</li>
    <li>测试2</li>
    <li>测试3</li>
  </ul>
  
  <button>点击跳转</button>

  请输入内容: <input type="text">
  <h1>三、其他事件</h1>


  <h1>四、元素尺寸与位置</h1>


  <script src="./shijianliu.js"></script>
</body>
</html>