<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <h1>测试js高阶内容</h1>

  <p>这是测试内容</p>


  <h2>构造函数</h2>
  <p>构造函数是专门用于创建对象的函数，如果一个函数使用 `new` 关键字调用，那么这个函数就是构造函数。

  function test(){
    console.log("测试构造函数  构造函数内部的 `return` 返回的值无效！")
  }    
  const Test = new test()
  </p>
  <h2>静态成员</h2>
  <p>
    在 JavaScript 中底层函数本质上也是对象类型，因此允许直接为函数动态添加属性或方法，构造函数的属性和方法被称为静态成员。
    <br>
    1. 静态成员指的是添加到构造函数本身的属性和方法
    <br>2. 一般公共特征的属性或方法静态成员设置为静态成员
    <br>3. 静态成员方法中的 `this` 指向构造函数本身
  </p>

  <h2>String数据类型 && Number数据类型</h2>

  <p>
    // 使用构造函数创建字符串 <br>

  let str = new String('hello world!');
  </p>
  <h2>原型对象</h2>
  <p>
    - JavaScript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象，所以我们也称为原型对象<br>
    - 这个对象可以挂载函数，对象实例化不会多次创建原型上函数，节约内存<br>
    - 我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。<br>
    - 构造函数和原型对象中的this 都指向 实例化的对象
  </p>






<script>

  //todo 原型对象
  function Student() {
    // 此处未定义任何方法
  }

  // 为构造函数的原型对象添加方法
  Student.prototype.sayHi = function () {
    console.log('Hi~');
  }
	
  // 实例化
  let p1 = new Student();
  p1.sayHi(); // 输出结果为 Hi~

  function Person(name) {
    this.name = name;
  }

  Person.prototype.sayHello = function() {
    console.log("Hello, ", this.name , "!")
  }

  let person1 = new Person("Alice")
  console.log("打印构造函数中的参数name: ",person1.name)
  // const person2 = new Person("Bob")
  person1.sayHello()// 输出: "Hello, Alice!"
  // person2.sayHello(); // 输出: "Hello, Bob!"

    
    const temp = new Array(1,33,12,44)
    temp.sort()
    console.log(temp)

    //静态变量
      // 构造函数
  function Person(name, age) {
    // 省略实例成员
  }
  
  // 静态属性
  Person.eyes = 2
  Person.arms = 2
  // 静态方法
  Person.walk = function () {
    console.log('^_^人都会走路...')
    // this 指向 Person
    console.log(this.eyes)
  }


    function Test() {
      console.log("测试构造函数  构造函数内部的 `return` 返回的值无效！")
    }    
    const test1 = new Test();   
    console.log(test1)

    // 
    const p = document.querySelector('p')
    console.log(p)
    test(1,2,3,4)





    /**
     * 测试函数的剩余参数 && 函数的隐含参数
     */
    function test(...other){
      console.log("测试函数的")
      for(let i =0 ; i <arguments.length ;i++){
        console.log(arguments[i])

      }
    
      // 剩余参数
      console.log(other)



      
    }
    //箭头函数
    //必须先声明， 然后再被调用，并且形参没有默认的arguments ，只可以用...other
    const fun =  (...other) => {
      console.log("这是箭头函数， 相当于Java中的Stream流")
      console.log("函数被传递的参数有: " ,other)
    }
    console.log(fun(1,2,2,33,12,31))


    //数组遍历的几种方法
    let arr = [55,4,33,22,12,2]

    //这就相当于调用函数了
    //和Java中的stream流使用类似
      const result = arr.forEach(function(item , index){
        console.log(item)
      })


    //不需要使用其他的再来调用
    const filers = arr.filter(item => item >= 10)
    console.log(filers)
  </script>
</body>
</html>